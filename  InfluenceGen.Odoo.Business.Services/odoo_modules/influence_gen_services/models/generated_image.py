# -*- coding: utf-8 -*-
import hashlib
import base64
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError

class InfluenceGenGeneratedImage(models.Model):
    _name = 'influence_gen.generated_image'
    _description = "AI Generated Image"
    _order = 'create_date desc'

    request_id = fields.Many2one(
        'influence_gen.ai_image_generation_request',
        string="Source Request",
        required=True,
        ondelete='cascade', # If request is deleted, its images are deleted
        index=True
    )
    user_id = fields.Many2one(
        related='request_id.user_id',
        string="Generated By User",
        store=True,
        readonly=True,
        index=True
    )
    influencer_profile_id = fields.Many2one(
        related='request_id.influencer_profile_id',
        string="Generated For Influencer",
        store=True,
        readonly=True,
        index=True
    )
    campaign_id = fields.Many2one(
        related='request_id.campaign_id',
        string="Associated Campaign",
        store=True,
        readonly=True,
        index=True
    )
    storage_attachment_id = fields.Many2one(
        'ir.attachment',
        string="Image File Attachment",
        required=True,
        ondelete='restrict' # Prevent deleting attachment if linked to this record directly
                           # Deletion should be handled by retention policies.
    )
    name = fields.Char(
        string="Image Name/Title", 
        related='storage_attachment_id.name', 
        readonly=False, # Allow user to rename logical image record if needed
        store=True       # Store for searchability, even if related
    )
    file_format = fields.Char(string="File Format", compute='_compute_file_details', store=True)
    file_size = fields.Integer(string="File Size (bytes)", compute='_compute_file_details', store=True)
    
    width = fields.Integer(string="Width (px)", related='request_id.resolution_width', store=True, readonly=True)
    height = fields.Integer(string="Height (px)", related='request_id.resolution_height', store=True, readonly=True)
    
    hash_value = fields.Char(string="Image Hash (SHA256)", index=True, readonly=True, copy=False)
    
    retention_category = fields.Selection([
        # Example categories, these should align with DataRetentionPolicy data_category
        ('personal_standard', 'Personal Use - Standard Retention'),
        ('campaign_short_term', 'Campaign Asset - Short Term'),
        ('campaign_long_term', 'Campaign Asset - Long Term Usage'),
        ('needs_review_retention', 'Needs Retention Review')
    ], string="Retention Category", required=True, index=True, default='needs_review_retention')
    
    usage_rights_details = fields.Text(string="Specific Usage Rights Applied", compute='_compute_usage_rights', store=True)
    is_submitted_to_campaign = fields.Boolean(
        string="Submitted to Campaign?", 
        compute='_compute_is_submitted_to_campaign', 
        store=True,
        help="Indicates if this image has been used in a content submission for a campaign."
    )
    
    @api.depends('storage_attachment_id.mimetype', 'storage_attachment_id.file_size')
    def _compute_file_details(self) -> None:
        for record in self:
            if record.storage_attachment_id:
                record.file_format = record.storage_attachment_id.mimetype
                record.file_size = record.storage_attachment_id.file_size
            else:
                record.file_format = False
                record.file_size = 0

    @api.model
    def create_from_generation(self, request_id_val: int, attachment_id_val: int, image_binary_data: bytes) -> models.Model:
        """
        Main method to create a GeneratedImage record after successful AI generation.
        REQ-AIGS-006, REQ-AIGS-010.
        """
        if not request_id_val or not attachment_id_val or not image_binary_data:
            raise ValueError(_("Request ID, Attachment ID, and image binary data are required."))

        request_rec = self.env['influence_gen.ai_image_generation_request'].browse(request_id_val)
        if not request_rec.exists():
            raise ValidationError(_("Source AI Generation Request not found."))
        
        attachment_rec = self.env['ir.attachment'].browse(attachment_id_val)
        if not attachment_rec.exists():
            raise ValidationError(_("Source Image Attachment not found."))

        # Calculate hash
        img_hash = hashlib.sha256(image_binary_data).hexdigest()

        # Determine retention_category
        retention_cat = 'personal_standard' # Default
        if request_rec.intended_use == 'campaign_specific' and request_rec.campaign_id:
            # Logic based on campaign usage rights duration
            if request_rec.campaign_id.usage_rights_duration_months and request_rec.campaign_id.usage_rights_duration_months > 12: # Example
                retention_cat = 'campaign_long_term'
            else:
                retention_cat = 'campaign_short_term'
        
        vals = {
            'request_id': request_id_val,
            'storage_attachment_id': attachment_id_val,
            'hash_value': img_hash,
            'retention_category': retention_cat,
            # name, file_format, file_size, width, height are computed or related
        }
        new_image = self.create(vals)

        self.env['influence_gen.audit_log_entry'].create_log(
            event_type='AI_IMAGE_CREATED',
            actor_user_id=request_rec.user_id.id, # Or system if N8N callback
            action_performed='CREATE_GENERATED_IMAGE',
            target_object=new_image,
            details_dict={
                'request_id': request_id_val,
                'attachment_id': attachment_id_val,
                'hash': img_hash,
                'retention_category': retention_cat
            }
        )
        request_rec._log_usage(event_type='AI_GENERATION_COMPLETED_IMAGE_STORED')
        return new_image

    @api.depends('request_id.campaign_id.usage_rights_description', 'request_id.intended_use', 'request_id.campaign_id.usage_rights_duration_months')
    def _compute_usage_rights(self) -> None:
        for record in self:
            if record.request_id.intended_use == 'campaign_specific' and record.request_id.campaign_id:
                details = record.request_id.campaign_id.usage_rights_description or ""
                if record.request_id.campaign_id.usage_rights_duration_months:
                    details += f" (Duration: {record.request_id.campaign_id.usage_rights_duration_months} months)"
                record.usage_rights_details = details
            else:
                # Default platform policy for personal use
                default_rights = self.env['influence_gen.platform_setting'].get_param(
                    'influence_gen.ai_image_personal_use_rights', 
                    _("For personal, non-commercial use on the InfluenceGen platform.")
                )
                record.usage_rights_details = default_rights
    
    @api.depends('id') # Depends on existence of ContentSubmission linking to this image
    def _compute_is_submitted_to_campaign(self) -> None:
        for record in self:
            submission_exists = self.env['influence_gen.content_submission'].search_count(
                [('generated_image_id', '=', record.id)]
            )
            record.is_submitted_to_campaign = bool(submission_exists)

    def action_apply_retention_policy(self) -> None:
        """
        Called by DataManagementService or scheduled job.
        REQ-AIGS-011, REQ-DRH-005.
        This method identifies if the image should be actioned based on policy.
        The actual action (delete/archive) might be performed by DataManagementService.
        """
        self.ensure_one()
        # This is a placeholder for the logic that DataManagementService would use.
        # It would fetch the relevant DataRetentionPolicy for self.retention_category,
        # check self.create_date against policy.retention_period_days.
        
        # Example:
        # policy = self.env['influence_gen.data_retention_policy'].get_active_policy(data_category=self.retention_category)
        # if policy and (fields.Date.today() - self.create_date.date()).days > policy.retention_period_days:
        #     if policy.disposition_action == 'delete':
        #         # Perform secure delete (unlink attachment, then self)
        #         self.storage_attachment_id.unlink() # This might fail if other records link to it, needs careful handling
        #         self.unlink()
        #     elif policy.disposition_action == 'archive':
        #         # Mark for archival or trigger archival process
        #         self.active = False # Example
        #     # Log action
        #     self.env['influence_gen.audit_log_entry'].create_log(...)
        pass