# -*- coding: utf-8 -*-
import hashlib
import base64
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError

class InfluenceGenGeneratedImage(models.Model):
    _name = 'influence_gen.generated_image'
    _description = "AI Generated Image"
    _order = 'create_date desc'

    request_id = fields.Many2one(
        'influence_gen.ai_image_generation_request',
        string="Source Request",
        required=True,
        ondelete='cascade', # If request is deleted, images are too
        index=True
    )
    user_id = fields.Many2one(
        related='request_id.user_id',
        string="Generated By User",
        store=True,
        readonly=True,
        index=True
    )
    influencer_profile_id = fields.Many2one(
        related='request_id.influencer_profile_id',
        string="Generated For Influencer",
        store=True,
        readonly=True,
        index=True
    )
    campaign_id = fields.Many2one(
        related='request_id.campaign_id',
        string="Associated Campaign",
        store=True,
        readonly=True,
        index=True
    )
    storage_attachment_id = fields.Many2one(
        'ir.attachment',
        string="Image File Attachment",
        required=True,
        ondelete='restrict' # Don't delete image record if attachment is unlinked manually
    )
    name = fields.Char(
        string="Image Name/Title",
        related='storage_attachment_id.name',
        readonly=False, # Allow overriding name, though related will update it
        store=True # Ensure it's stored for searchability if needed
    )
    file_format = fields.Char(string="File Format", compute='_compute_file_details', store=True)
    file_size = fields.Integer(string="File Size (bytes)", compute='_compute_file_details', store=True)
    width = fields.Integer(string="Width (px)", related='request_id.resolution_width', store=True, readonly=True)
    height = fields.Integer(string="Height (px)", related='request_id.resolution_height', store=True, readonly=True)
    hash_value = fields.Char(string="Image Hash (SHA256)", index=True, readonly=True, copy=False)
    retention_category = fields.Selection([
        ('personal_temporary', 'Personal - Temporary'),
        ('personal_long_term', 'Personal - Long Term'),
        ('campaign_submission', 'Campaign Submission'),
        ('campaign_asset_short_term', 'Campaign Asset - Short Term'), # Example: 3 months
        ('campaign_asset_medium_term', 'Campaign Asset - Medium Term'), # Example: 1 year
        ('campaign_asset_long_term', 'Campaign Asset - Long Term'), # Example: 5 years
        ('platform_content', 'Platform Content')
        # Define more categories as needed by DataRetentionPolicy
    ], string="Retention Category", required=True, index=True)
    usage_rights_details = fields.Text(string="Specific Usage Rights Applied", compute='_compute_usage_rights', store=True)
    is_submitted_to_campaign = fields.Boolean(
        string="Submitted to Campaign?",
        compute='_compute_is_submitted_to_campaign',
        store=True
    )

    @api.depends('storage_attachment_id.mimetype', 'storage_attachment_id.file_size')
    def _compute_file_details(self):
        for record in self:
            if record.storage_attachment_id:
                record.file_format = record.storage_attachment_id.mimetype
                record.file_size = record.storage_attachment_id.file_size
            else:
                record.file_format = False
                record.file_size = 0

    @api.model
    def create_from_generation(cls, request_id_val, attachment_id_val, image_binary_data):
        """Main method to create a GeneratedImage record after successful AI generation.
        REQ-AIGS-006, REQ-AIGS-010.
        """
        request_record = cls.env['influence_gen.ai_image_generation_request'].browse(request_id_val)
        if not request_record.exists():
            raise ValidationError(_("Source AI Generation Request not found."))
        attachment_record = cls.env['ir.attachment'].browse(attachment_id_val)
        if not attachment_record.exists():
            raise ValidationError(_("Image attachment not found."))

        # Calculate hash
        try:
            # If image_binary_data is base64 encoded string (typical for attachments in Odoo)
            img_data = base64.b64decode(image_binary_data)
            hash_object = hashlib.sha256(img_data)
        except TypeError: # if image_binary_data is already bytes
             hash_object = hashlib.sha256(image_binary_data)
        image_hash = hash_object.hexdigest()

        # Determine retention category
        retention_cat = 'personal_temporary' # Default
        if request_record.intended_use == 'campaign_specific' and request_record.campaign_id:
            retention_cat = 'campaign_submission' # Default for campaign, can be refined
            # Example:
            # if request_record.campaign_id.usage_rights_duration_months:
            #     if request_record.campaign_id.usage_rights_duration_months <= 3:
            #         retention_cat = 'campaign_asset_short_term'
            #     elif request_record.campaign_id.usage_rights_duration_months <= 12:
            #         retention_cat = 'campaign_asset_medium_term'
            #     else:
            #         retention_cat = 'campaign_asset_long_term'

        vals = {
            'request_id': request_id_val,
            'storage_attachment_id': attachment_id_val,
            'hash_value': image_hash,
            'retention_category': retention_cat,
            # width, height, file_format, file_size will be computed or are on request/attachment
        }
        new_image = cls.create(vals)

        cls.env['influence_gen.audit_log_entry'].create_log(
            event_type='AI_IMAGE_CREATED',
            actor_user_id=request_record.user_id.id, # Or system if N8N callback is system user
            action_performed='CREATE',
            target_object=new_image,
            details_dict={'request_id': request_id_val, 'attachment_id': attachment_id_val}
        )
        return new_image

    @api.depends('request_id.campaign_id.usage_rights_description', 'request_id.intended_use')
    def _compute_usage_rights(self):
        for record in self:
            if record.request_id.intended_use == 'campaign_specific' and record.request_id.campaign_id:
                record.usage_rights_details = record.request_id.campaign_id.usage_rights_description
            else:
                # Default platform policy for personal use images
                default_policy = self.env['influence_gen.platform_setting'].get_param(
                    'influence_gen.ai_image_personal_use_rights',
                    default="For personal, non-commercial use only. Subject to platform ToS."
                )
                record.usage_rights_details = default_policy

    @api.depends('id') # Depends on existence and linkage in content_submission
    def _compute_is_submitted_to_campaign(self):
        for record in self:
            submission_count = self.env['influence_gen.content_submission'].search_count([
                ('generated_image_id', '=', record.id)
            ])
            record.is_submitted_to_campaign = submission_count > 0

    def action_apply_retention_policy(self):
        """Called by DataManagementService or scheduled job. REQ-AIGS-011, REQ-DRH-005."""
        # This method is a placeholder for the logic that would be invoked.
        # The actual checking of dates and policy is done in DataManagementService.
        # This method could, for example, perform the actual unlink or anonymization.
        self.ensure_one()
        # Example:
        # if self.retention_category == 'personal_temporary' and ready_for_deletion:
        #     self.storage_attachment_id.unlink() # This might be too direct, infra layer might handle secure deletion
        #     self.unlink()
        #     self.env['influence_gen.audit_log_entry'].create_log(...)
        
        # For now, it's a conceptual method. The DataManagementService would query images
        # based on their create_date and retention_category, then call appropriate actions.
        # A direct call here might not have enough context on *why* it's being applied.
        
        # A more practical approach within the DataManagementService would be:
        # images_to_delete = self.env['influence_gen.generated_image'].search(domain_based_on_policy)
        # for image in images_to_delete:
        #     # Perform deletion/anonymization logic
        #     image.storage_attachment_id.unlink() # Or call infra service for secure deletion
        #     image.unlink()
        #     # Log action
        return True