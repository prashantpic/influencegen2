# -*- coding: utf-8 -*-
import hashlib
from odoo import api, fields, models, _
from odoo.exceptions import ValidationError

class InfluenceGenGeneratedImage(models.Model):
    _name = 'influence_gen.generated_image'
    _description = "AI Generated Image"
    _order = 'create_date desc'

    request_id = fields.Many2one(
        'influence_gen.ai_image_generation_request', string="Source Request",
        required=True, ondelete='cascade', index=True
    )
    user_id = fields.Many2one(
        related='request_id.user_id', string="Generated By User",
        store=True, readonly=True, index=True
    )
    influencer_profile_id = fields.Many2one(
        related='request_id.influencer_profile_id', string="Generated For Influencer",
        store=True, readonly=True, index=True
    )
    campaign_id = fields.Many2one(
        related='request_id.campaign_id', string="Associated Campaign",
        store=True, readonly=True, index=True
    )
    storage_attachment_id = fields.Many2one(
        'ir.attachment', string="Image File Attachment",
        required=True, ondelete='restrict' # Restrict deletion of attachment if image record exists
    )
    name = fields.Char(
        string="Image Name/Title", related='storage_attachment_id.name',
        readonly=False, store=True # Allow editing name on attachment, reflect here
    )
    file_format = fields.Char(string="File Format", compute='_compute_file_details', store=True)
    file_size = fields.Integer(string="File Size (bytes)", compute='_compute_file_details', store=True)
    width = fields.Integer(
        string="Width (px)", related='request_id.resolution_width',
        store=True, readonly=True
    )
    height = fields.Integer(
        string="Height (px)", related='request_id.resolution_height',
        store=True, readonly=True
    )
    hash_value = fields.Char(string="Image Hash (SHA256)", index=True, readonly=True)
    retention_category = fields.Selection([
        ('personal_short_term', 'Personal - Short Term'),
        ('personal_long_term', 'Personal - Long Term'),
        ('campaign_active', 'Campaign - Active'),
        ('campaign_archived_usage', 'Campaign - Archived (Usage Rights)'),
        ('campaign_expired_usage', 'Campaign - Archived (Expired Usage)'),
        ('legal_hold', 'Legal Hold'),
        # Add more categories as needed
    ], string="Retention Category", required=True, index=True, default='personal_short_term')
    usage_rights_details = fields.Text(string="Specific Usage Rights Applied", compute='_compute_usage_rights', store=True)
    is_submitted_to_campaign = fields.Boolean(
        string="Submitted to Campaign?", compute='_compute_is_submitted_to_campaign',
        store=True # May need to adjust store based on performance if many submissions
    )

    @api.depends('storage_attachment_id.mimetype', 'storage_attachment_id.file_size')
    def _compute_file_details(self):
        for image in self:
            if image.storage_attachment_id:
                image.file_format = image.storage_attachment_id.mimetype
                image.file_size = image.storage_attachment_id.file_size
            else:
                image.file_format = False
                image.file_size = 0

    @api.model
    def create_from_generation(cls, request_id_val, attachment_id_val, image_binary_data):
        """
        Main method to create a GeneratedImage record after successful AI generation.
        REQ-AIGS-006, REQ-AIGS-010.
        """
        request_rec = cls.env['influence_gen.ai_image_generation_request'].browse(request_id_val)
        if not request_rec.exists():
            raise ValidationError(_("Source AI Generation Request not found."))
        
        attachment_rec = cls.env['ir.attachment'].browse(attachment_id_val)
        if not attachment_rec.exists():
            raise ValidationError(_("Image file attachment not found."))

        # Calculate hash
        try:
            hash_value = hashlib.sha256(image_binary_data).hexdigest()
        except Exception as e:
            _logger.error(f"Failed to calculate hash for image from request {request_id_val}: {e}")
            hash_value = None # Or raise error if hash is mandatory

        # Determine retention category
        retention_category = 'personal_short_term' # Default
        if request_rec.intended_use == 'campaign_specific' and request_rec.campaign_id:
            retention_category = 'campaign_active'
            # More complex logic based on usage_rights_duration_months can be added
            # e.g., if request_rec.campaign_id.usage_rights_duration_months > 12:
            #    retention_category = 'campaign_long_usage' 
        elif request_rec.intended_use == 'personal_exploration':
            # Potentially use a platform setting for personal exploration retention
            retention_category = cls.env['influence_gen.platform_setting'].get_param(
                'influence_gen.ai_image_personal_retention_category', 
                default='personal_short_term'
            )


        image_vals = {
            'request_id': request_id_val,
            'storage_attachment_id': attachment_id_val,
            'hash_value': hash_value,
            'retention_category': retention_category,
            # width and height are related from request, file_format and file_size computed
        }
        
        image = cls.create(image_vals)

        cls.env['influence_gen.audit_log_entry'].create_log(
            event_type='AI_IMAGE_CREATED',
            actor_user_id=request_rec.user_id.id, # Generated by user's request
            action_performed='CREATE_IMAGE_FROM_GENERATION',
            target_object=image,
            details_dict={'request_id': request_id_val, 'attachment_id': attachment_id_val}
        )
        return image

    @api.depends('request_id.campaign_id.usage_rights_description', 'request_id.intended_use', 'request_id.campaign_id.usage_rights_duration_months')
    def _compute_usage_rights(self):
        for image in self:
            if image.request_id.intended_use == 'campaign_specific' and image.request_id.campaign_id:
                details = image.request_id.campaign_id.usage_rights_description or ""
                duration = image.request_id.campaign_id.usage_rights_duration_months
                if duration:
                    details += f" (Duration: {duration} months)"
                image.usage_rights_details = details
            else:
                # Default platform policy for personal use images
                image.usage_rights_details = self.env['influence_gen.platform_setting'].get_param(
                    'influence_gen.ai_image_personal_usage_rights',
                    default="For personal, non-commercial use only."
                )
    
    @api.depends('id') # Recompute if content submissions change, this is a simplification
    def _compute_is_submitted_to_campaign(self):
        for image in self:
            submission = self.env['influence_gen.content_submission'].search_count([
                ('generated_image_id', '=', image.id)
            ])
            image.is_submitted_to_campaign = bool(submission)

    def action_apply_retention_policy(self):
        """
        Called by DataManagementService or scheduled job.
        REQ-AIGS-011, REQ-DRH-005.
        This method itself doesn't decide *which* records to apply to;
        it performs the action on the given recordset if it's due.
        The DataManagementService is responsible for finding records eligible for policy application.
        """
        # This method would be part of a larger process in DataManagementService
        # For each image `self` in the recordset passed by the service:
        # 1. Get the policy for `self.retention_category`
        # 2. Check if `self.create_date` + `policy.retention_period_days` < today
        # 3. If so, perform `policy.disposition_action`
        # This specific method on the model might just perform the unlink/archive action itself.
        
        # Example for 'delete' disposition:
        # self.storage_attachment_id.unlink() # Unlink attachment first if desired
        # self.unlink()
        # self.env['influence_gen.audit_log_entry'].create_log(...)
        
        _logger.info("action_apply_retention_policy called for image(s) %s (Logic handled by DataManagementService)", self.ids)
        return True